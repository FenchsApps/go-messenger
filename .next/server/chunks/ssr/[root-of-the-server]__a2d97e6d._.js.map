{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/filter-profanity.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview Implements profanity filtering using Genkit.\n *\n * - filterProfanity - A function that filters explicit content.\n * - FilterProfanityInput - The input type for the filterProfanity function.\n * - FilterProfanityOutput - The return type for the filterProfanity function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst FilterProfanityInputSchema = z.object({\n  text: z\n    .string()\n    .describe(\"The text to filter for profanity and explicit content.\"),\n});\nexport type FilterProfanityInput = z.infer<typeof FilterProfanityInputSchema>;\n\nconst FilterProfanityOutputSchema = z.object({\n  filteredText: z\n    .string()\n    .describe(\"The filtered text with profanity and explicit content removed.\"),\n});\nexport type FilterProfanityOutput = z.infer<typeof FilterProfanityOutputSchema>;\n\nexport async function filterProfanity(input: FilterProfanityInput): Promise<FilterProfanityOutput> {\n  return filterProfanityFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'filterProfanityPrompt',\n  input: {schema: FilterProfanityInputSchema},\n  output: {schema: FilterProfanityOutputSchema},\n  prompt: `You are a content moderation AI responsible for filtering profanity and explicit language from user-generated text.  You must use reasoning to determine whether the content should be filtered.\n\n  Here is the text to filter:\n  {{text}}\n\n  Return the filtered text. If the text does not contain profanity, return the original text.\n  Even if a word is not directly a swear, you need to check if it is used in a profane context and filter it appropriately.\n  If you are unsure, filter the word.\n  `,\n});\n\nconst filterProfanityFlow = ai.defineFlow(\n  {\n    name: 'filterProfanityFlow',\n    inputSchema: FilterProfanityInputSchema,\n    outputSchema: FilterProfanityOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,6BAA6B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,MAAM,uIAAA,CAAA,IAAC,CACJ,MAAM,GACN,QAAQ,CAAC;AACd;AAGA,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,cAAc,uIAAA,CAAA,IAAC,CACZ,MAAM,GACN,QAAQ,CAAC;AACd;AAGO,eAAe,gBAAgB,KAA2B;IAC/D,OAAO,oBAAoB;AAC7B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAA0B;IAC1C,QAAQ;QAAC,QAAQ;IAA2B;IAC5C,QAAQ,CAAC;;;;;;;;EAQT,CAAC;AACH;AAEA,MAAM,sBAAsB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACvC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IA5BoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase.ts"],"sourcesContent":["// @ts-nocheck\nimport { initializeApp, getApp, getApps } from 'firebase/app';\nimport { getFirestore, enableMultiTabIndexedDbPersistence } from 'firebase/firestore';\nimport { getAuth } from 'firebase/auth';\nimport { getStorage } from 'firebase/storage';\n\n// Your web app's Firebase configuration\n// IMPORTANT: Replace this with your own Firebase project configuration!\n// You can get this from the Firebase console:\n// Project settings > General > Your apps > Web app > Firebase SDK snippet > Config\nconst firebaseConfig = {\n\n  apiKey: \"AIzaSyCJhbJ9Hx4ZzDneeSrPE-W1Hh7ifI1Ydxw\",\n\n  authDomain: \"coo-messenger-dut4g.firebaseapp.com\",\n\n  projectId: \"coo-messenger-dut4g\",\n\n  storageBucket: \"coo-messenger-dut4g.firebasestorage.app\",\n\n  messagingSenderId: \"289105120218\",\n\n  appId: \"1:289105120218:web:0a828e96df9dc829edcee3\"\n\n};\n\n\n\n\nconst app = !getApps().length ? initializeApp(firebaseConfig) : getApp();\nconst db = getFirestore(app);\nconst auth = getAuth(app);\nconst storage = getStorage(app);\n\n\n// This enables offline persistence. It's best to call this only once.\ntry {\n  enableMultiTabIndexedDbPersistence(db)\n    .catch((err) => {\n      if (err.code === 'failed-precondition') {\n        // Multiple tabs open, persistence can only be enabled in one tab at a time.\n        console.log('Firebase persistence failed: multiple tabs open.');\n      } else if (err.code === 'unimplemented') {\n        // The current browser does not support all of the\n        // features required to enable persistence\n         console.log('Firebase persistence failed: browser does not support it.');\n      }\n    });\n} catch(e) {\n    console.error(\"Firebase persistence error\", e);\n}\n\n\nexport { app, db, auth, storage };\n"],"names":[],"mappings":"AAAA,cAAc;;;;;;;AACd;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAEA,wCAAwC;AACxC,wEAAwE;AACxE,8CAA8C;AAC9C,mFAAmF;AACnF,MAAM,iBAAiB;IAErB,QAAQ;IAER,YAAY;IAEZ,WAAW;IAEX,eAAe;IAEf,mBAAmB;IAEnB,OAAO;AAET;AAKA,MAAM,MAAM,CAAC,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,GAAG,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE,kBAAkB,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD;AACrE,MAAM,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE;AACxB,MAAM,OAAO,CAAA,GAAA,yOAAA,CAAA,UAAO,AAAD,EAAE;AACrB,MAAM,UAAU,CAAA,GAAA,oLAAA,CAAA,aAAU,AAAD,EAAE;AAG3B,sEAAsE;AACtE,IAAI;IACF,CAAA,GAAA,iKAAA,CAAA,qCAAkC,AAAD,EAAE,IAChC,KAAK,CAAC,CAAC;QACN,IAAI,IAAI,IAAI,KAAK,uBAAuB;YACtC,4EAA4E;YAC5E,QAAQ,GAAG,CAAC;QACd,OAAO,IAAI,IAAI,IAAI,KAAK,iBAAiB;YACvC,kDAAkD;YAClD,0CAA0C;YACzC,QAAQ,GAAG,CAAC;QACf;IACF;AACJ,EAAE,OAAM,GAAG;IACP,QAAQ,KAAK,CAAC,8BAA8B;AAChD","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["\n// @ts-nocheck\n'use server';\nimport { filterProfanity } from '@/ai/flows/filter-profanity';\nimport { db, storage } from '@/lib/firebase';\nimport { addDoc, collection, serverTimestamp, doc, updateDoc, deleteDoc, getDocs, writeBatch, query, where, getDoc, setDoc } from 'firebase/firestore';\nimport { ref, uploadString, getDownloadURL } from 'firebase/storage';\n\nexport async function getFilteredMessage(text: string) {\n  if (!text.trim()) {\n    return { error: 'Message cannot be empty', data: null };\n  }\n\n  try {\n    const { filteredText } = await filterProfanity({ text });\n    return {\n      error: null,\n      data: {\n        id: crypto.randomUUID(),\n        text: filteredText,\n      }\n    };\n  } catch (error) {\n    console.error('Error filtering profanity:', error);\n    // Fallback to original text if AI fails\n    return {\n      error: 'Failed to process message with AI',\n      data: {\n        id: crypto.randomUUID(),\n        text: text,\n      }\n    };\n  }\n}\n\nfunction getChatId(userId1: string, userId2: string) {\n    return [userId1, userId2].sort().join('_');\n}\n\nexport async function sendMessage(senderId: string, recipientId: string, text: string, forwardedFrom?: { name: string, text: string }) {\n    if (!text.trim()) {\n        return { error: 'Message cannot be empty' };\n    }\n    \n    const chatId = getChatId(senderId, recipientId);\n    \n    try {\n        const docRef = await addDoc(collection(db, 'chats', chatId, 'messages'), {\n            senderId,\n            recipientId,\n            text,\n            timestamp: serverTimestamp(),\n            type: 'text',\n            edited: false,\n            forwardedFrom: forwardedFrom || null,\n            read: false,\n        });\n        return { error: null, data: { id: docRef.id, text } };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { error: 'Failed to send message' };\n    }\n}\n\nexport async function sendSticker(senderId: string, recipientId: string, stickerId: string) {\n    const chatId = getChatId(senderId, recipientId);\n    \n    try {\n        const docRef = await addDoc(collection(db, 'chats', chatId, 'messages'), {\n            senderId,\n            recipientId,\n            text: '',\n            timestamp: serverTimestamp(),\n            type: 'sticker',\n            stickerId,\n            read: false,\n        });\n        return { error: null, data: { id: docRef.id, stickerId } };\n    } catch (error) {\n        console.error(\"Error sending sticker:\", error);\n        return { error: 'Failed to send sticker' };\n    }\n}\n\nexport async function sendGif(senderId: string, recipientId: string, gifUrl: string) {\n    const chatId = getChatId(senderId, recipientId);\n    \n    try {\n        const docRef = await addDoc(collection(db, 'chats', chatId, 'messages'), {\n            senderId,\n            recipientId,\n            text: '',\n            timestamp: serverTimestamp(),\n            type: 'gif',\n            gifUrl,\n            read: false,\n        });\n        return { error: null, data: { id: docRef.id, gifUrl } };\n    } catch (error) {\n        console.error(\"Error sending GIF:\", error);\n        return { error: 'Failed to send GIF' };\n    }\n}\n\nexport async function searchGifs(query: string) {\n  const apiKey = process.env.GIPHY_API_KEY;\n  if (!apiKey) {\n    console.error('GIPHY API key not found.');\n    return { error: 'GIF service is not configured.' };\n  }\n  \n  const url = `https://api.giphy.com/v1/gifs/search?api_key=${apiKey}&q=${encodeURIComponent(query)}&limit=21&offset=0&rating=g&lang=en`;\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('GIPHY API error:', response.status, errorText);\n      return { error: 'Failed to fetch GIFs from GIPHY.' };\n    }\n    const data = await response.json();\n    const gifs = data.data.map((r: any) => ({\n      id: r.id,\n      url: r.images.fixed_height.url,\n      preview: r.images.fixed_height_small.url,\n    }));\n    return { data: gifs };\n  } catch (error) {\n    console.error('Error fetching GIFs from GIPHY:', error);\n    return { error: 'Failed to fetch GIFs.' };\n  }\n}\n\n\nexport async function editMessage(chatId: string, messageId: string, newText: string) {\n    if (!newText.trim()) {\n        return { error: \"Message can't be empty\" };\n    }\n    try {\n        const messageRef = doc(db, 'chats', chatId, 'messages', messageId);\n        await updateDoc(messageRef, {\n            text: newText,\n            edited: true,\n        });\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error editing message:\", error);\n        return { error: 'Failed to edit message' };\n    }\n}\n\nexport async function deleteMessage(chatId: string, messageId: string) {\n    try {\n        const messageRef = doc(db, 'chats', chatId, 'messages', messageId);\n        await deleteDoc(messageRef);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error deleting message:\", error);\n        return { error: 'Failed to delete message' };\n    }\n}\n\nexport async function markMessagesAsRead(chatId: string, currentUserId: string) {\n    const messagesRef = collection(db, 'chats', chatId, 'messages');\n    const q = query(messagesRef, where('recipientId', '==', currentUserId), where('read', '==', false));\n    \n    try {\n        const querySnapshot = await getDocs(q);\n        if (querySnapshot.empty) {\n            return; // No unread messages to mark\n        }\n        \n        const batch = writeBatch(db);\n        querySnapshot.forEach(doc => {\n            batch.update(doc.ref, { read: true });\n        });\n        await batch.commit();\n    } catch (error) {\n        console.error(\"Error marking messages as read: \", error);\n    }\n}\n\nexport async function clearChatHistory(chatId: string) {\n    const messagesRef = collection(db, 'chats', chatId, 'messages');\n    try {\n        const querySnapshot = await getDocs(messagesRef);\n        const batch = writeBatch(db);\n        querySnapshot.forEach(doc => {\n            batch.delete(doc.ref);\n        });\n        await batch.commit();\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error clearing chat history: \", error);\n        return { error: 'Failed to clear chat history.' };\n    }\n}\n\n// Call actions\nexport async function createCall(callerId: string, recipientId: string) {\n    try {\n        const callDocRef = await addDoc(collection(db, 'calls'), {\n            callerId,\n            recipientId,\n            status: 'ringing',\n            createdAt: serverTimestamp()\n        });\n        return { id: callDocRef.id };\n    } catch (error) {\n        console.error(\"Error creating call:\", error);\n        return { error: 'Failed to create call' };\n    }\n}\n\nexport async function sendCallSignal(callId: string, signalData: any) {\n    try {\n        const signalsCollection = collection(db, 'calls', callId, 'signals');\n        await addDoc(signalsCollection, {\n            ...signalData,\n            createdAt: serverTimestamp()\n        });\n    } catch (error) {\n        console.error(\"Error sending call signal:\", error);\n    }\n}\n\nexport async function updateCallStatus(callId: string, status: 'active' | 'ended' | 'declined' | 'ringing') {\n    try {\n        const callDocRef = doc(db, 'calls', callId);\n        await updateDoc(callDocRef, { status });\n    } catch (error) {\n        console.error(\"Error updating call status:\", error);\n    }\n}\n\nexport async function endCall(callId: string) {\n    try {\n        if (!callId) return;\n        const callDocRef = doc(db, 'calls', callId);\n        \n        // Check if the document exists before trying to delete it and its subcollections\n        const callDocSnap = await getDoc(callDocRef);\n        if (callDocSnap.exists()) {\n             // Delete signals subcollection\n            const signalsSnapshot = await getDocs(collection(callDocRef, 'signals'));\n            const batch = writeBatch(db);\n            signalsSnapshot.forEach(doc => {\n                batch.delete(doc.ref);\n            });\n            await batch.commit();\n\n            // Delete the call document itself\n            await deleteDoc(callDocRef);\n        }\n       \n    } catch (error) {\n        // It might fail if the other user already deleted it, which is fine.\n        console.log(\"Could not delete call doc, it might have been deleted already.\", error);\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 702, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {sendMessage as '78aa2447a300bdb474f91bdc8f096d1589fc2797dc'} from 'ACTIONS_MODULE0'\nexport {sendSticker as '702e1c340d1eab2bea22e72f39e9f5e78357cf0ea1'} from 'ACTIONS_MODULE0'\nexport {editMessage as '705763b4cc11e647e621930ce50f6aa5850bc05850'} from 'ACTIONS_MODULE0'\nexport {deleteMessage as '6082a68fb814428b566b32d551d95980da5a0e9c05'} from 'ACTIONS_MODULE0'\nexport {sendGif as '705394123808f77ae076418e2562d4b6e3695e2f20'} from 'ACTIONS_MODULE0'\nexport {markMessagesAsRead as '6017f6d2a4ed6ee70bb28fd0a9f062866349785ef9'} from 'ACTIONS_MODULE0'\nexport {clearChatHistory as '40f784cb07841038eb7841f8782797dc636cd57a95'} from 'ACTIONS_MODULE0'\nexport {createCall as '60fb389e04dca841d04740b6dcff4e853ec414c442'} from 'ACTIONS_MODULE0'\nexport {endCall as '402f289fcd4a5ff6202bc7a9f7fb3b32020a9a908c'} from 'ACTIONS_MODULE0'\nexport {sendCallSignal as '601821dda6ba9148b86f738bbab53f2e4b9645b31c'} from 'ACTIONS_MODULE0'\nexport {updateCallStatus as '60a53473e44b1197fd7e48ac4fbf54d37643f07461'} from 'ACTIONS_MODULE0'\nexport {searchGifs as '409e93a08092ba11b70da181b8437860f103d7cbfb'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 787, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/login.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Login = registerClientReference(\n    function() { throw new Error(\"Attempted to call Login() from the server but Login is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/login.tsx <module evaluation>\",\n    \"Login\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,QAAQ,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACvC;IAAa,MAAM,IAAI,MAAM;AAA0N,GACvP,0DACA","debugId":null}},
    {"offset": {"line": 801, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/login.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Login = registerClientReference(\n    function() { throw new Error(\"Attempted to call Login() from the server but Login is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/login.tsx\",\n    \"Login\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,QAAQ,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACvC;IAAa,MAAM,IAAI,MAAM;AAA0N,GACvP,sCACA","debugId":null}},
    {"offset": {"line": 815, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 825, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["import { Login } from '@/components/login';\n\nexport default function Home() {\n  return <Login />;\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,SAAS;IACtB,qBAAO,8OAAC,2HAAA,CAAA,QAAK;;;;;AACf","debugId":null}}]
}