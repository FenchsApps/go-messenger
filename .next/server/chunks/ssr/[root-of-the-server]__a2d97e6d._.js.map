{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.0-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/filter-profanity.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview Implements profanity filtering using Genkit.\n *\n * - filterProfanity - A function that filters explicit content.\n * - FilterProfanityInput - The input type for the filterProfanity function.\n * - FilterProfanityOutput - The return type for the filterProfanity function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst FilterProfanityInputSchema = z.object({\n  text: z\n    .string()\n    .describe(\"The text to filter for profanity and explicit content.\"),\n});\nexport type FilterProfanityInput = z.infer<typeof FilterProfanityInputSchema>;\n\nconst FilterProfanityOutputSchema = z.object({\n  filteredText: z\n    .string()\n    .describe(\"The filtered text with profanity and explicit content removed.\"),\n});\nexport type FilterProfanityOutput = z.infer<typeof FilterProfanityOutputSchema>;\n\nexport async function filterProfanity(input: FilterProfanityInput): Promise<FilterProfanityOutput> {\n  return filterProfanityFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'filterProfanityPrompt',\n  input: {schema: FilterProfanityInputSchema},\n  output: {schema: FilterProfanityOutputSchema},\n  prompt: `You are a content moderation AI responsible for filtering profanity and explicit language from user-generated text.  You must use reasoning to determine whether the content should be filtered.\n\n  Here is the text to filter:\n  {{text}}\n\n  Return the filtered text. If the text does not contain profanity, return the original text.\n  Even if a word is not directly a swear, you need to check if it is used in a profane context and filter it appropriately.\n  If you are unsure, filter the word.\n  `,\n});\n\nconst filterProfanityFlow = ai.defineFlow(\n  {\n    name: 'filterProfanityFlow',\n    inputSchema: FilterProfanityInputSchema,\n    outputSchema: FilterProfanityOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,6BAA6B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,MAAM,uIAAA,CAAA,IAAC,CACJ,MAAM,GACN,QAAQ,CAAC;AACd;AAGA,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,cAAc,uIAAA,CAAA,IAAC,CACZ,MAAM,GACN,QAAQ,CAAC;AACd;AAGO,eAAe,gBAAgB,KAA2B;IAC/D,OAAO,oBAAoB;AAC7B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAA0B;IAC1C,QAAQ;QAAC,QAAQ;IAA2B;IAC5C,QAAQ,CAAC;;;;;;;;EAQT,CAAC;AACH;AAEA,MAAM,sBAAsB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACvC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IA5BoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase.ts"],"sourcesContent":["// @ts-nocheck\nimport { initializeApp, getApp, getApps } from 'firebase/app';\nimport { getFirestore, enableMultiTabIndexedDbPersistence } from 'firebase/firestore';\nimport { getAuth } from 'firebase/auth';\nimport { getStorage } from 'firebase/storage';\n\n// Your web app's Firebase configuration\n// IMPORTANT: Replace this with your own Firebase project configuration!\n// You can get this from the Firebase console:\n// Project settings > General > Your apps > Web app > Firebase SDK snippet > Config\nconst firebaseConfig = {\n\n  apiKey: \"AIzaSyCJhbJ9Hx4ZzDneeSrPE-W1Hh7ifI1Ydxw\",\n\n  authDomain: \"coo-messenger-dut4g.firebaseapp.com\",\n\n  projectId: \"coo-messenger-dut4g\",\n\n  storageBucket: \"coo-messenger-dut4g.firebasestorage.app\",\n\n  messagingSenderId: \"289105120218\",\n\n  appId: \"1:289105120218:web:0a828e96df9dc829edcee3\"\n\n};\n\n\n\n\nconst app = !getApps().length ? initializeApp(firebaseConfig) : getApp();\nconst db = getFirestore(app);\nconst auth = getAuth(app);\nconst storage = getStorage(app);\n\n\n// This enables offline persistence. It's best to call this only once.\ntry {\n  enableMultiTabIndexedDbPersistence(db)\n    .catch((err) => {\n      if (err.code === 'failed-precondition') {\n        // Multiple tabs open, persistence can only be enabled in one tab at a time.\n        console.log('Firebase persistence failed: multiple tabs open.');\n      } else if (err.code === 'unimplemented') {\n        // The current browser does not support all of the\n        // features required to enable persistence\n         console.log('Firebase persistence failed: browser does not support it.');\n      }\n    });\n} catch(e) {\n    console.error(\"Firebase persistence error\", e);\n}\n\n\nexport { app, db, auth, storage };\n"],"names":[],"mappings":"AAAA,cAAc;;;;;;;AACd;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAEA,wCAAwC;AACxC,wEAAwE;AACxE,8CAA8C;AAC9C,mFAAmF;AACnF,MAAM,iBAAiB;IAErB,QAAQ;IAER,YAAY;IAEZ,WAAW;IAEX,eAAe;IAEf,mBAAmB;IAEnB,OAAO;AAET;AAKA,MAAM,MAAM,CAAC,CAAA,GAAA,oLAAA,CAAA,UAAO,AAAD,IAAI,MAAM,GAAG,CAAA,GAAA,oLAAA,CAAA,gBAAa,AAAD,EAAE,kBAAkB,CAAA,GAAA,oLAAA,CAAA,SAAM,AAAD;AACrE,MAAM,KAAK,CAAA,GAAA,iKAAA,CAAA,eAAY,AAAD,EAAE;AACxB,MAAM,OAAO,CAAA,GAAA,yOAAA,CAAA,UAAO,AAAD,EAAE;AACrB,MAAM,UAAU,CAAA,GAAA,oLAAA,CAAA,aAAU,AAAD,EAAE;AAG3B,sEAAsE;AACtE,IAAI;IACF,CAAA,GAAA,iKAAA,CAAA,qCAAkC,AAAD,EAAE,IAChC,KAAK,CAAC,CAAC;QACN,IAAI,IAAI,IAAI,KAAK,uBAAuB;YACtC,4EAA4E;YAC5E,QAAQ,GAAG,CAAC;QACd,OAAO,IAAI,IAAI,IAAI,KAAK,iBAAiB;YACvC,kDAAkD;YAClD,0CAA0C;YACzC,QAAQ,GAAG,CAAC;QACf;IACF;AACJ,EAAE,OAAM,GAAG;IACP,QAAQ,KAAK,CAAC,8BAA8B;AAChD","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["// @ts-nocheck\n'use server';\nimport { filterProfanity } from '@/ai/flows/filter-profanity';\nimport { db, storage } from '@/lib/firebase';\nimport { addDoc, collection, serverTimestamp, doc, updateDoc, deleteDoc, getDoc, setDoc } from 'firebase/firestore';\nimport { ref, uploadString, getDownloadURL } from 'firebase/storage';\n\nexport async function getFilteredMessage(text: string) {\n  if (!text.trim()) {\n    return { error: 'Message cannot be empty', data: null };\n  }\n\n  try {\n    const { filteredText } = await filterProfanity({ text });\n    return {\n      error: null,\n      data: {\n        id: crypto.randomUUID(),\n        text: filteredText,\n      }\n    };\n  } catch (error) {\n    console.error('Error filtering profanity:', error);\n    // Fallback to original text if AI fails\n    return {\n      error: 'Failed to process message with AI',\n      data: {\n        id: crypto.randomUUID(),\n        text: text,\n      }\n    };\n  }\n}\n\nfunction getChatId(userId1: string, userId2: string) {\n    return [userId1, userId2].sort().join('_');\n}\n\nexport async function sendMessage(senderId: string, recipientId: string, text: string, forwardedFrom?: { name: string, text: string }, callInfo?: { status: 'answered' | 'declined' | 'missed', duration?: number }) {\n    if (!text.trim() && !callInfo) {\n        return { error: 'Message cannot be empty' };\n    }\n    \n    const chatId = getChatId(senderId, recipientId);\n    \n    try {\n        const docRef = await addDoc(collection(db, 'chats', chatId, 'messages'), {\n            senderId,\n            recipientId,\n            text,\n            timestamp: serverTimestamp(),\n            type: callInfo ? 'call' : 'text',\n            edited: false,\n            forwardedFrom: forwardedFrom || null,\n            callInfo: callInfo || null,\n        });\n        return { error: null, data: { id: docRef.id, text } };\n    } catch (error) {\n        console.error(\"Error sending message:\", error);\n        return { error: 'Failed to send message' };\n    }\n}\n\nexport async function sendSticker(senderId: string, recipientId: string, stickerId: string) {\n    const chatId = getChatId(senderId, recipientId);\n    \n    try {\n        const docRef = await addDoc(collection(db, 'chats', chatId, 'messages'), {\n            senderId,\n            recipientId,\n            text: '',\n            timestamp: serverTimestamp(),\n            type: 'sticker',\n            stickerId,\n        });\n        return { error: null, data: { id: docRef.id, stickerId } };\n    } catch (error) {\n        console.error(\"Error sending sticker:\", error);\n        return { error: 'Failed to send sticker' };\n    }\n}\n\nexport async function sendGif(senderId: string, recipientId: string, gifUrl: string) {\n    const chatId = getChatId(senderId, recipientId);\n    \n    try {\n        const docRef = await addDoc(collection(db, 'chats', chatId, 'messages'), {\n            senderId,\n            recipientId,\n            text: '',\n            timestamp: serverTimestamp(),\n            type: 'gif',\n            gifUrl,\n        });\n        return { error: null, data: { id: docRef.id, gifUrl } };\n    } catch (error) {\n        console.error(\"Error sending GIF:\", error);\n        return { error: 'Failed to send GIF' };\n    }\n}\n\nexport async function searchGifs(query: string) {\n  const apiKey = process.env.GIPHY_API_KEY;\n  if (!apiKey) {\n    console.error('GIPHY API key not found.');\n    return { error: 'GIF service is not configured.' };\n  }\n  \n  const url = `https://api.giphy.com/v1/gifs/search?api_key=${apiKey}&q=${encodeURIComponent(query)}&limit=21&offset=0&rating=g&lang=en`;\n\n  try {\n    const response = await fetch(url);\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('GIPHY API error:', response.status, errorText);\n      return { error: 'Failed to fetch GIFs from GIPHY.' };\n    }\n    const data = await response.json();\n    const gifs = data.data.map((r: any) => ({\n      id: r.id,\n      url: r.images.fixed_height.url,\n      preview: r.images.fixed_height_small.url,\n    }));\n    return { data: gifs };\n  } catch (error) {\n    console.error('Error fetching GIFs from GIPHY:', error);\n    return { error: 'Failed to fetch GIFs.' };\n  }\n}\n\n\nexport async function editMessage(chatId: string, messageId: string, newText: string) {\n    if (!newText.trim()) {\n        return { error: \"Message can't be empty\" };\n    }\n    try {\n        const messageRef = doc(db, 'chats', chatId, 'messages', messageId);\n        await updateDoc(messageRef, {\n            text: newText,\n            edited: true,\n        });\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error editing message:\", error);\n        return { error: 'Failed to edit message' };\n    }\n}\n\nexport async function deleteMessage(chatId: string, messageId: string) {\n    try {\n        const messageRef = doc(db, 'chats', chatId, 'messages', messageId);\n        await deleteDoc(messageRef);\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error deleting message:\", error);\n        return { error: 'Failed to delete message' };\n    }\n}\n\n\n// WebRTC Signaling Actions\nexport async function createCallOffer(chatId: string, offer: RTCSessionDescriptionInit) {\n  const callDocRef = doc(db, 'calls', chatId);\n  await setDoc(callDocRef, {\n    offer,\n    status: 'ringing',\n    createdAt: serverTimestamp(),\n  });\n}\n\nexport async function createCallAnswer(chatId: string, answer: RTCSessionDescriptionInit) {\n  const callDocRef = doc(db, 'calls', chatId);\n  await updateDoc(callDocRef, { answer, status: 'answered' });\n}\n\nexport async function addIceCandidate(chatId: string, candidate: RTCIceCandidateInit) {\n  const callDocRef = doc(db, 'calls', chatId);\n  const callDoc = await getDoc(callDocRef);\n  if (callDoc.exists()) {\n    const data = callDoc.data();\n    // Use a more robust way to update array to avoid race conditions if possible\n    const candidates = data.iceCandidates || [];\n    await updateDoc(callDocRef, {\n      iceCandidates: [...candidates, candidate],\n    });\n  }\n}\n\nexport async function updateCallStatus(\n    chatId: string, \n    status: 'declined' | 'ended' | 'answered', \n    duration?: number,\n    callerId?: string,\n    calleeId?: string,\n) {\n    const callDocRef = doc(db, 'calls', chatId);\n    const callDoc = await getDoc(callDocRef);\n\n    if (callDoc.exists()) {\n        const callData = callDoc.data();\n        if (status === 'ended' || status === 'declined') {\n            \n            if(callerId && calleeId) {\n                // Determine the correct call status for the message\n                // If callData.status is not 'answered', it was missed (if not declined)\n                let finalStatus = callData.status === 'answered' ? 'answered' : 'missed';\n                if (status === 'declined') {\n                    finalStatus = 'declined';\n                }\n\n                let messageText = 'Звонок';\n                 if(finalStatus === 'answered') {\n                    messageText = `Звонок длительностью ${duration} сек.`\n                 } else if (finalStatus === 'declined') {\n                    messageText = 'Звонок отклонен'\n                 } else if (finalStatus === 'missed') {\n                    messageText = 'Пропущенный звонок'\n                 }\n\n                await sendMessage(callerId, calleeId, messageText, undefined, {\n                    status: finalStatus as 'answered' | 'declined' | 'missed',\n                    duration: duration,\n                })\n            }\n            await deleteDoc(callDocRef);\n        } else if (status === 'answered') {\n            await updateDoc(callDocRef, { status });\n        }\n    } else if(status === 'answered') {\n        // If doc doesn't exist and we are answering, create it.\n        // This can happen in a race condition.\n        await setDoc(callDocRef, { status }, { merge: true });\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {sendMessage as '7caa2447a300bdb474f91bdc8f096d1589fc2797dc'} from 'ACTIONS_MODULE0'\nexport {sendSticker as '702e1c340d1eab2bea22e72f39e9f5e78357cf0ea1'} from 'ACTIONS_MODULE0'\nexport {editMessage as '705763b4cc11e647e621930ce50f6aa5850bc05850'} from 'ACTIONS_MODULE0'\nexport {deleteMessage as '6082a68fb814428b566b32d551d95980da5a0e9c05'} from 'ACTIONS_MODULE0'\nexport {sendGif as '705394123808f77ae076418e2562d4b6e3695e2f20'} from 'ACTIONS_MODULE0'\nexport {createCallAnswer as '6040f336319d499f4f8fb5ee6879c5eee6b49a0fbf'} from 'ACTIONS_MODULE0'\nexport {updateCallStatus as '7ca53473e44b1197fd7e48ac4fbf54d37643f07461'} from 'ACTIONS_MODULE0'\nexport {createCallOffer as '60ebe43e685c27f63aae9b9bcc8269d30c2244126b'} from 'ACTIONS_MODULE0'\nexport {searchGifs as '409e93a08092ba11b70da181b8437860f103d7cbfb'} from 'ACTIONS_MODULE0'\nexport {addIceCandidate as '60683cf55ab4a59e76eb7909f0c39798439d5d6c92'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 746, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/login.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Login = registerClientReference(\n    function() { throw new Error(\"Attempted to call Login() from the server but Login is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/login.tsx <module evaluation>\",\n    \"Login\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,QAAQ,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACvC;IAAa,MAAM,IAAI,MAAM;AAA0N,GACvP,0DACA","debugId":null}},
    {"offset": {"line": 760, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/login.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const Login = registerClientReference(\n    function() { throw new Error(\"Attempted to call Login() from the server but Login is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/login.tsx\",\n    \"Login\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,QAAQ,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACvC;IAAa,MAAM,IAAI,MAAM;AAA0N,GACvP,sCACA","debugId":null}},
    {"offset": {"line": 774, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 784, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["import { Login } from '@/components/login';\n\nexport default function Home() {\n  return <Login />;\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,SAAS;IACtB,qBAAO,8OAAC,2HAAA,CAAA,QAAK;;;;;AACf","debugId":null}}]
}